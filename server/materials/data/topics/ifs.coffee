import contest from "../../lib/contest"
import label from "../../lib/label"
import page from "../../lib/page"
import problem from "../../lib/problem"
import topic from "../../lib/topic"

module15986 = () ->
    page("Разбор задачи про Франциска Ксавьера (читать только тем, кто решил саму задачу!)", String.raw"""
        <div class="box generalbox generalboxcontent boxaligncenter clearfix"><h2>Разбор задачи про Франциска Ксавьера</h2>
        <p>Если вы еще не решили задачу про день святого Франциска Ксавьера из контеста "Продвинутые задачи на условный оператор", то не читайте дальше, сначала решите задачу.</p><br>
        -<br>-<br>-<br>-<br>-<br>-<br>-<br>-<br>-<br>-<br>-<br>-<br>-<br>-<br>
        <p>Как можно решать эту задачу? Конечно, можно решить тупо: прогнать цикл от года рождения до года смерти и каждый год проверить. По условию годы не превосходят 2000, поэтому такое решение вполне успеет по времени.</p>
        <p>Но это — задачи на условный оператор, поэтому решение с циклами разрешать я тут не буду. Тем более что в принципе понятно сразу, что задачу можно решить, просто сделав  немного вычислений, без циклов — так что программа будет работать очень быстро независимо от входных данных. (А решение с циклом может очень медленно работать, если годы во входных данных могут быть очень большими — например, на тесте 0 1000000000.) (Тем не менее, это все относится к нашему учебному курсу. Если бы такая задача вам попалась бы на олимпиаде, то, конечно, надо было бы просто написать цикл.)</p>
        <p>Как написать такое решение? В принципе, можно работать с данными «как есть», просто написать несколько if'ов, и в каждом сразу вычислять и считать ответ. Пример такого решения:
        </p><pre>{$mode delphi}
        var r,s:integer;
        begin
        read(r,s);
        if (s&lt;1605) then writeln(0)
        else if ((r=1605) or (r mod 10=5)) then writeln((s-r) div 10)
        else if (r&gt;1605) then
        	if (r mod 10&lt;5) then writeln((s-(r-r mod 10 +5))div 10 +1)
        	else writeln((s-(r-r mod 10 +15))div 10 +1)
        else writeln((s-1605) div 10 +1);
        end.
        </pre>
        Но такое решение писать довольно сложно (и вообще, я на 100% не уверен, что решение выше верное — оно, конечно, проходит все тесты, но я не уверен, что тесты там достаточно полные).<p></p>
        <p>Проще поступить следующим образом — и на самом деле это подход, встречающийся во многих задачах. Надо понимать, что у вас нет цели написать одну большую формулу (ну или несколько формул с разбором случаев). Компьютер способен на более сложные действия, и этим надо воспользоваться.</p>
        <p>Итак, пусть мы считали данные:
        </p><pre>s, f = map(int, input().split())</pre>
        (s и f от start и finish).
        <p></p>
        
        <p>Давайте, во-первых, сдвинем начало отсчета времени на 1605 год, т.е. вычтем из всех годов 1605:
        </p><pre>s = s - 1605
        f = f - 1605
        </pre>
        Это уже существенно упростит задачу: теперь нас интересуют года, делящиеся на 10, с этим работать намного проще, чем с годами, которые дают остаток 5 при делении на 10. Кроме того, дальше нам сравнения надо будет делать не с 1605, а с нулем, что позволяет не ошибиться с годом.<p></p>
        
        <p>Уже теперь формулы и if'ы будут проще. Но мы пойдем далее и вместо годов рождения и смерти посчитаем и будем использовать <i>первый год</i>, когда он мог коснуться мощей, и последний такой год.</p>
        <p>Как определить первый год, когда он мог коснуться мощей? Казалось бы, это первый год, кратный десяти, после года рождения. Соответствующую формулу несложно придумать:</p>
        <pre>s = s - s % 10 + 10
        </pre>
        <p>Правда, как только вы написали это выражение (или даже как только подумали про это), надо тут же подумать: а всегда ли это работает? Тут же должны возникнуть четыре соображения:</p>
        <ul>
        <li>А если s кратно 10 сразу?</li>
        <li>А если полученный год больше года смерти?</li>
        <li>А если полученный год меньше нуля?</li>
        <li>А верно ли это работает для отрицательных <code>s</code>?</li>
        </ul>
        <p>На первый вопрос ответ простой: наша формула сработает верно. Действительно, по условию в год рождения крестьянин не мог касаться мощей, поэтому если год рождения был кратен 10, то первый год, когда он мог коснуться мощей, будет на 10 лет позже — это наша формула и дает.</p>
        <p>Второй вопрос пока запомним, его рассмотрим позже; кроме того, запомним сразу, что надо будет проверить такой тест — например, тест 3 5, точнее, с учетом того, что мы вычитали 1605 из всех годов, то тест 1608 1610.</p>
        <p>Четвертый вопрос на самом деле не вопрос: в питоне взятие остатка для отрицательных чисел работает разумно (например, <code>(-3) % 10 == 7</code>, подумайте, почему это разумно). В результате если изначально было <code>s = -3</code>, то у нас получится <code>s = 0</code>, что и следовало ожидать. Вот в других языках программирования с этим надо аккуратно обойтись.</p>
        <p>И наконец третий вопрос обрабатывается легко: если полученный год меньше нуля, то на самом деле первый раз крестьянин мог коснуться мощей в нулевом году:</p>
        <pre>if s &lt; 0:
            s = 0
        </pre>
        <p>Аналогично поступим с годом смерти: нам надо определить последний год, кратный 10, который был не позже года смерти. Формула еще проще:</p>
        <pre>f = f - f % 10
        </pre>
        <p>Здесь тоже возникают те же четыре вопроса, точнее уже два вопроса, потому что с поведением остатка от деления для отрицательных чисел мы уже разобрались, а вопросы "полученный год меньше года рождения" и "полученный год меньше нуля" — это теперь одна и та же ситуация. Ее мы рассмотрим позже, а на оставшийся вопрос "если f кратно 10 сразу" ответ такой же: наш код работает правильно, т.к. в год смерти он мог коснуться мощей.</p>
        <p>Теперь мы знаем первый и последний год, когда крестьянин мог коснуться мощей. Ответ на задачу уже вычисляется совсем легко: <code>(f-s) // 10 + 1</code>, только надо не забыть те вопросы, которые мы откладывали. Несложно видеть, что они все объединяются в один <code>if f &lt; s</code>, и в итоге получаем простой вывод ответа:</p>
        <pre>if f &lt; s: 
            print(0)
        else:
            print((f-s) // 10 + 1)
        </pre>
        Вот и все. Итоговая программа:
        <pre>s, f = map(int, input().split())
        s = s - 1605
        f = f - 1605
        
        s = s - s % 10 + 10
        if s &lt; 0:
            s = 0
        
        f = f - f % 10
        
        if f &lt; s: 
            print(0)
        else:
            print((f-s) // 10 + 1)
        </pre>
        <p>Программа намного проще, чем та, что приведена в начале. Ошибки в ней искать тоже намного проще, т.к. можно проверять ее по частям; мы прекрасно понимаем, в чем физический смысл каждого куска.</p>
        <p>(В частности, если бы это был бы не питон, то у вас возникли бы обсуждаемые выше проблемы с остатками для отрицательных чисел. Например, что в c++, что в паскале получается <code>(-3) % 10 == -3</code> (c++) и <code>(-3) mod 10 == -3</code> (паскаль), поэтому коррекции <code>s</code> и <code>f</code> будут неверными. Надо такие случаи учитывать особо, но в любом случае как только вы находите такой баг, вы сразу понимаете, где он и как его исправить. В решении с кучей вложенных if'ов искать такую ошибку было бы намного сложнее.</p>
        <p>Итак, и это полезно не только в этой задаче, но и во многих других. Если вы понимаете, что задача решается формулой, не надо сразу бросаться эту формулу писать. Компьютер может сделать дополнительные действия, вы можете провести какие-то вычисления, например, упростив входные данные, или вычислив какие-нибудь дополнительные переменные, и т.д. Не бойтесь этого делать.</p>
        <p>И вторая мораль: если вы видите, что вы можете упростить входные данные к задаче, это зачастую полезно сделать. Последовательно упрощая данные, вы делаете решение проще и проще.</p></div>
    """, {skipTree: true})

export default ifs = () ->
    return {
        topic: topic("Условный оператор", "Задачи на условный оператор", [
            label("<a href=\"https://notes.algoprog.ru/python_basics/1_if.html\">Питон: теория по условному оператору</a>"),
            label("<a href=\"https://blog.algoprog.ru/do-not-check-limits/\">Не надо проверять, выполняются ли ограничения из условия</a>"),
            problem(292),
            problem(293),
            problem(2959),
            problem(294),
            problem(253),
        ], "ifs"),
        advancedTopics: [
            contest("Продвинутые задачи на условный оператор: в них запрещено пользоваться циклами и массивами", [
                problem(297),
                problem(255),
                problem(258),
                problem(38),
                problem(264),
                problem(235),
                problem(303),
                problem(481),
                problem(234),
            ]),
            module15986()            
        ]
    }
